===============Общие сведения:
Узнать тип переменной(typeof переменная)

Если складывать строку с числом, будет строка.

NaN-Not a number(не число)
Число+underfind=NaN


==============Преобразование строки в число:

1.parsInt('строка' или переменная)-Преобразование строки к числу //работает только с целыми числами
2.Number('строка' или переменная)-Преобразование строки к числу
3.Поставить + перед переменной или строкой и тогда Преобразует строку в число// работает с целыми и с float
4.parseFloat('строка' или переменная)-Преобразование строки к числу //только floa

==================Работа со строками:
trim()-очистить строку от пробелов
charAt()-показать определенный символ
indexOf()-возвращает первый индекс, по которому данный элемент может быть найден в массиве,если такого нет в массиве вернет -1
repeat()-повторение строки
===============Тернарные выражения:
if(age<10){
     alert('А')
     }else {
         alert('b')
     }
Данное выражение можно написать по другому
age<10 ? alert('a') : alert ('b')
Где  знак вопроса -это истина и тогда выведет сообщение с буквой а;
А двоиточие- это else


============Функции:
Отличие function declaration от function expression в том, что 
function declaration можно вызывать из любого места, даже после объявления, в то время как function expression
надо сначало объявить и только потом можно вызывать.

синтаксис стрелочной функции:

==Пример обычной функции:

function Hello(){
    console.log('Hello')
}
==Стрелочная функция
const Hello=()=>console.log('Hello') ----В скобках передаются параметры
--Как мы помним, у стрелочных функций нет собственного this. 
--Теперь мы знаем, что нет и своего объекта arguments.

 =========Массивы:
 Методы для работы с массивами
 push()-добавляет элемент в конец массива 
 unshift()-добавляет элемент в начало массива
 shift()-удаляет первый элемент массива, а также возвращает первый элемент массива.
 pop()-тоже самое что и shift, но только с последнем элементом
 reverse()-переворачивает массив и перезаписывает его
 indexOf()-показывает индекс элемента в массиве
 findIndex()-возвращает индекс в массиве, при этом это цикл который пробегает по массиву
 find/filter(func) – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
 includes()-des() проверяет, содержит ли строка заданную подстроку, и возвращает, соответственно true или false.
 map()- создаёт новый массив из результатов вызова func для каждого элемента.
  Для перебора массива:
  forEach(func) – вызывает func для каждого элемента. Ничего не возвращает.

---------Map-коллекция пар ключ-значение
ew Map([iterable]) – создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар [ключ,значение] для инициализации.
map.set(key, value) – записывает по ключу key значение value.
map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
map.delete(key) – удаляет элемент по ключу key.
map.clear() – очищает коллекцию от всех элементов.
map.size – возвращает текущее количество элементов.

----Отличия от обычного объекта Object:
Что угодно может быть ключом, в том числе и объекты.
Есть дополнительные методы, свойство size.

--------Set-коллекция уникальных значений, так называемое «множество»
new Set([iterable]) – создаёт Set, можно указать перебираемый объект со значениями для инициализации.
set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
set.delete(value) – удаляет значение, возвращает true если value было в множестве на момент вызова, иначе false.
set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
set.clear() – удаляет все имеющиеся значения.
set.size – возвращает количество элементов в множестве.


--------WeakMap – это Map-подобная коллекция, позволяющая использовать в качестве ключей только объекты, и автоматически удаляющая 
их вместе с соответствующими значениями, как только они становятся недостижимыми иными путями.
--------WeakSet – это Set-подобная коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми иными путями.

Обе этих структуры данных не поддерживают методы и свойства, работающие со всем содержимым сразу или возвращающие информацию о размере коллекции. 
Возможны только операции на отдельном элементе коллекции.

WeakMap и WeakSet используются как вспомогательные структуры данных в дополнение к «основному» месту хранения объекта. Если объект удаляется из основного
хранилища и нигде не используется, кроме как в качестве ключа в WeakMap или в WeakSet, то он будет удалён автоматически.

 ===========Деструктуризация объекта:
  это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части.

  ===Пример:
  Есть объект
  const person = {
    name: 'Victor',
    age: 20,
    isProgrammer: true,
    languages: ['ru', 'en', 'de'],
    'complex key': 'Complex Value', //key_4
    ['key_' + (1 + 3)]: 'Computed Key',
    greet() {
        console.log('greet from person')

    }
}

const name = person.name
const age = person.age
const languages= person.languages
Чтобы не присваивать каждое свойства объекта новой переменной как в примере выше
можно делать вот так:
====const {name,age,languages}=person
console.log(name,age,languages)
вывод получится такой же, это и называется деструктуризация объекта
Если мы хотим поменять название переменной, то ставим двоеточие пишем название переменной
где 'age-свойство объекта' а personAge-переменная которой присваивается значение.
const {name,age:personAge,languages}=person

========Json-это общий формат для представления значений и объектов
 Таким образом, JSON легко использовать для обмена данными, когда клиент использует JavaScript
 Типичные ошибки при работе с JSON =>>
 let json = `{
  name: "John",                     // Ошибка: имя свойства без кавычек
  "surname": 'Smith',               // Ошибка: одинарные кавычки в значении (должны быть двойными)
  'isAdmin': false                  // Ошибка: одинарные кавычки в ключе (должны быть двойными)
  "birthday": new Date(2000, 2, 3), // Ошибка: не допускается конструктор "new", только значения.
  "friends": [0,1,2,3]                     // Здесь всё в порядке
}`;
Кроме того, JSON не поддерживает комментарии. Добавление комментария в JSON делает его недействительным.